// Copyright (c) 2017 Vadim Macagon
// MIT License, see LICENSE file for full terms.

import { getEnv, getRoot, process, types } from 'mobx-state-tree';

import { Omit } from '../../common/typescript-extensions';
import { AppDatabase, IRepositoryRecord } from './app-database';
import { IAppStoreEnv } from './app-store';

export const RepositoryModel = types.model('Repository', {
  /** Unique id (generated by the database). */
  id: types.identifier(types.number),
  /** The root directory of the repository. */
  localPath: types.string,
  /** Name to use when displaying the repository in the UI. */
  name: types.string
});

export type IRepositoryModel = typeof RepositoryModel.Type;
export type INewRepositoryInfo = Omit<IRepositoryModel, 'id'>;

/**
 * Stores information about local git repositories.
 *
 * The store contents are persisted to a local database. Contents must be loaded by invoking
 * the async `load()` action after the store is created.
 */
export const RepositoryStore = types
  .model('RepositoryStore', {
    repositories: types.optional(types.array(RepositoryModel), [])
  })
  .views(self => {
    return {
      /**
       * Find a repository matching the given identifier.
       *
       * @return A repository, or `null` if no match was found.
       */
      findById(repositoryId: number): IRepositoryModel | null {
        return self.repositories.find(repo => repo.id === repositoryId) || null;
      }
    };
  })
  .actions(self => {
    // mobx-state-tree (as at version 0.11.0) forbids passing in an environment to a child
    // node in the state tree, so because this store will be attached to the AppStore it can't get
    // its own environment. To work around this limitation we grab what we need from the AppStore
    // environment after this store is attached to the AppStore.
    let db: AppDatabase | null = null;

    function* addRepository(repoInfo: INewRepositoryInfo) {
      const id: number = yield db!.repositoryTable.add(repoInfo);
      self.repositories.push(Object.assign({ id }, repoInfo));
      return id;
    }

    function* removeRepository(repositoryId: number) {
      yield db!.repositoryTable.delete(repositoryId);
      const repository = self.repositories.find(repo => repo.id === repositoryId);
      self.repositories.remove(repository);
    }

    function* load() {
      type Record = IRepositoryRecord & { id: number };
      const repos: Record[] = yield db!.repositoryTable.toArray();
      self.repositories.replace(repos);
    }

    // The type definition for the `process` function doesn't have a very useful return type
    // so gotta use a type assertion in most cases to make it a bit less vague.
    return {
      afterAttach: () => (db = getEnv<IAppStoreEnv>(getRoot(self)).db),
      /**
       * Create a new repository with the given info and add it to the database.
       *
       * @return A promise that will be resolved with the id of the new repository.
       */
      addRepository: process(addRepository) as (repoInfo: INewRepositoryInfo) => Promise<number>,
      /**
       * Remove a repository matching the given id from the database.
       *
       * This action should only be invoked from the AppStore to ensure the currently selected
       * repository is updated, @see AppStore.removeRepository.
       *
       * @return A promise that will be resolved when the operation completes.
       */
      removeRepository: process(removeRepository) as (repositoryId: number) => Promise<void>,
      /**
       * Populate the store from the database.
       *
       * @return A promise that will be resolved when the operation completes.
       */
      load: process<void>(load)
    };
  });

export type IRepositoryStore = typeof RepositoryStore.Type;
