// Copyright (c) 2017 Vadim Macagon
// MIT License, see LICENSE file for full terms.

import { getEnv, getRoot, process, types } from 'mobx-state-tree';

import { AppDatabase, IRepositoryRecord } from './app-database';
import { IAppStoreEnv } from './app-store';
import {
  GitStore,
  IBranchModel,
  ICommitModel,
  ILoadNextHistoryBatchOptions,
  isTipBranchValid
} from './git-store';

export const RepositoryModel = types
  .model('Repository', {
    /** Unique id (generated by the database). */
    id: types.identifier(types.number),
    /** The root directory of the repository. */
    localPath: types.string,
    /** Name to use when displaying the repository in the UI. */
    name: types.string,
    gitStore: types.maybe(GitStore)
  })
  .views(self => ({
    get currentBranch(): IBranchModel | null {
      if (self.gitStore && isTipBranchValid(self.gitStore.tip)) {
        return self.gitStore.tip.branch;
      }
      return null;
    },
    get totalHistorySize(): number {
      return self.gitStore!.totalHistorySize;
    },
    get commits(): ICommitModel[] {
      return self.gitStore!.loadedCommits;
    }
  }))
  .actions(self => ({
    afterCreate: () => (self.gitStore = GitStore.create({ localPath: self.localPath })),
    refreshStatus: () => self.gitStore!.refreshStatus(),
    loadHistory: () => self.gitStore!.loadFirstHistoryBatch(),
    loadMoreHistory: (options?: ILoadNextHistoryBatchOptions) =>
      self.gitStore!.loadNextHistoryBatch(options)
  }));

export type IRepositoryModel = typeof RepositoryModel.Type;

export interface INewRepositoryInfo {
  localPath: IRepositoryModel['localPath'];
  name: IRepositoryModel['name'];
}

/**
 * Stores information about local git repositories.
 *
 * The store contents are persisted to a local database. Contents must be loaded by invoking
 * the async `load()` action after the store is created.
 */
export const RepositoryStore = types
  .model('RepositoryStore', {
    repositories: types.optional(types.array(RepositoryModel), [])
  })
  .views(self => {
    return {
      /**
       * Find a repository matching the given identifier.
       *
       * @return A repository, or `null` if no match was found.
       */
      findById(repositoryId: number): IRepositoryModel | null {
        return self.repositories.find(repo => repo.id === repositoryId) || null;
      }
    };
  })
  .actions(self => {
    // mobx-state-tree (as at version 0.11.0) forbids passing in an environment to a child
    // node in the state tree, so because this store will be attached to the AppStore it can't get
    // its own environment. To work around this limitation we grab what we need from the AppStore
    // environment after this store is attached to the AppStore.
    let db: AppDatabase | null = null;

    function* addRepository(repoInfo: INewRepositoryInfo) {
      const id: number = yield db!.repositoryTable.add(repoInfo);
      self.repositories.push(
        RepositoryModel.create({
          id,
          localPath: repoInfo.localPath,
          name: repoInfo.name,
          gitStore: null
        })
      );
      return id;
    }

    function* removeRepository(repositoryId: number) {
      yield db!.repositoryTable.delete(repositoryId);
      const repository = self.repositories.find(repo => repo.id === repositoryId);
      self.repositories.remove(repository);
    }

    function* load() {
      type Record = IRepositoryRecord & { id: number };
      const records: Record[] = yield db!.repositoryTable.toArray();
      const repos = records.map(r =>
        RepositoryModel.create({ id: r.id, localPath: r.localPath, name: r.name, gitStore: null })
      );
      self.repositories.replace(repos);
    }

    // The type definition for the `process` function doesn't have a very useful return type
    // so gotta use a type assertion in most cases to make it a bit less vague.
    return {
      afterAttach: () => (db = getEnv<IAppStoreEnv>(getRoot(self)).db),
      /**
       * Create a new repository with the given info and add it to the database.
       *
       * @return A promise that will be resolved with the id of the new repository.
       */
      addRepository: process(addRepository) as (repoInfo: INewRepositoryInfo) => Promise<number>,
      /**
       * Remove a repository matching the given id from the database.
       *
       * This action should only be invoked from the AppStore to ensure the currently selected
       * repository is updated, @see AppStore.removeRepository.
       *
       * @return A promise that will be resolved when the operation completes.
       */
      removeRepository: process(removeRepository) as (repositoryId: number) => Promise<void>,
      /**
       * Populate the store from the database.
       *
       * @return A promise that will be resolved when the operation completes.
       */
      load: process<void>(load)
    };
  });

export type IRepositoryStore = typeof RepositoryStore.Type;
